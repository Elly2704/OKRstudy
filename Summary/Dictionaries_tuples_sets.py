# Словари (dict)  - неупорядоченные коллекции произвольных объектов с доступом по ключу.
# Создание словаря

d = {}
d = dict()
d = dict.fromkeys(['a', 'b']) # формирует словарь с ключами, указанными в списке

#Методы словарей
dict.clear() - очищает словарь.
dict.copy() - возвращает копию словаря.
classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).
dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает
default (по умолчанию None).
dict.items() - возвращает пары (ключ, значение).
dict.keys() - возвращает ключи в словаре.
dict.pop(key[, default]) - удаляет ключ и возвращает значение.
dict.popitem() - удаляет произвольное значение
dict.setdefault(key,[default]) - возвращает значение ключа, но если его нет, не бросает исключение,
а создает ключ со значением default (по умолчанию None).
dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other.
Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
dict.values() - возвращает значения в словаре.

for key, value in data.items():
    print(key, value)

#  Вводятся данные в формате ключ=значение в одну строчку через пробел.
a = input().split()
for i in range(len(a)):
    a[i] = a[i].split('=')
    a[i][1] = int(a[i][1])
d = dict(a)
print(*sorted(d.items()))

# Кортежи - неизменяемые списки, упорядоченные коллекции. Применяются методы списка которые не изменяют его.
tuple = ()
a = tuple()
a = ('s', ) # кортеж из одного элемента

tuple.count(значение) – возвращает число найденных элементов с указанным значением;
tuple.index(значение[, start[, stop]]) – возвращает индекс первого найденного элемента с указанным значением
(start и stop – необязательные параметры, индексы начала и конца поиска).

res = ()
for i in range(len(a)):
    t=tuple(a[i].split())
    res+=(t,)
print(res)

# Множества (set) и их методы
# множество (set) – это неупорядоченная коллекция уникальных элементов. Уникальных, то есть,
# в ней отсутствуют дублирующие значения. (frozenset - неизменяемое множество)
a = set()
a = {'a', 'b', 'c', 'd'} #Пустое множество создать нельзя

#Операции с множествами
len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение (уникальные значения из обоих множеств которые есть
и в одном и в друго одновременно)
a = set(input().split())
b = set(input().split())
s = a&b
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве,
но не встречающиеся в обоих. (уникальные значения из обоих множеств не пересекающиеся)
a = set(map(int,input().split()))
b = set(map(int,input().split()))
s = a ^ b
set.copy() - копия множества.
set.update(other, ...); set |= other | ... - объединение.
set.add(elem) - добавляет элемент в множество.
set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
set.discard(elem) - удаляет элемент, если он находится в множестве.
set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
set.clear() - очистка множества.

# Генераторы множеств и словарей
d = input().split()
x = {key: value for key, value in enumerate(d[1:], int(d[0])) if value.isalpha()}
print(x.get(4))

a = {i for i in lst_in}
print(len(a))

# Вводится текст в одну строчку со словами через пробел. С помощью генератора множеств сформировать множество
# из уникальных слов без учета регистра и длина которых не менее трех символов. Вывести на экран размер этого множества.
s = set(input().lower().split())
res = {i for i in s if len(i) >= 3}
print(len(res))

