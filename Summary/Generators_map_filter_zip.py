# Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов.
# Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение прерывается.
# Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.
(<формирование значения> for <переменная> in <итерируемый объект>)

gen = (i for i in range(10000))

# Функция - генератор
def get_sum(n):
    for i in range(1,n + 1):
        a = range(1,i+1)
        yield sum(a)

N = int(input())
def func(N):
    a = 1
    b = 1
    c = 1
    for i in range(N):
        if i < 3:
            yield 1
        else:
            yield a + b + c
            a, b, c = b, c, (a + b + c)
print(*list(func(N)))

# Функция map() - это встроенная функция, которая позволяет обрабатывать и преобразовывать все элементы
# в итерируемом объекте без использования явного цикла for, методом, широко известным как сопоставление (mapping).
# map() полезен, когда вам нужно применить функцию преобразования к каждому элементу в коллекции или в массиве и преобразовать их в новый массив.

lst = list(map(lambda x: abs(int(x)), input().split()))

# Функция filter() в Python применяет другую функцию к заданному итерируемому объекту
# (список, строка, словарь и так далее), проверяя, нужно ли сохранить конкретный элемент или нет.
# Простыми словами, она отфильтровывает то, что не проходит и возвращает все остальное.

a = input().split()
def lens(a):
    if len(a) > 5:
        return a

b = filter(lens,a) # условие -  длина слова
print(*list(b))

# Функция zip() создает итератор, который объединяет элементы из нескольких источников данных.

coordinate = ['x', 'y', 'z']
value = [3, 4, 5]

result = zip(coordinate, value)
result_list = list(result)
print(result_list)

# Функции isinstance(), с помощью которой можно выполнять проверку на принадлежность объекта определенным типам данных.
# Определите функцию с именем get_add, которая складывает или два числа или две строки (но не число со строкой)
# и возвращает полученный результат. Если сложение не может быть выполнено, то функция возвращает значение None.
def get_add(a, b):
    if type(a) == bool or type(b) == bool or (isinstance(a, str) and not isinstance(b, str)) or (
            not isinstance(a, str) and isinstance(b, str)):
        return None
    else:
        return a + b

# all() все значения True
a = all(map(lambda x: x < 0, a))
# any() хотя бы одно значение True
a = any(map(lambda x: x < 0, a))